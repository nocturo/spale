// Minimal libFuzzer harness for hpke_verify_and_decrypt
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <openssl/crypto.h>
#include "hpke.h"

// Fixed test vectors (not secret) for fuzzing context
static const uint8_t kServerSk[32] = {
    0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00,
    0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x80,0x90,0xa0,0xb0,0xc0,0xd0,0xe0,0xf0,0x01
};
static const uint8_t kClientPk[32] = {
    0x9a,0x2b,0x3c,0x4d,0x5e,0x6f,0x70,0x81,0x92,0xa3,0xb4,0xc5,0xd6,0xe7,0xf8,0x09,
    0x19,0x28,0x37,0x46,0x55,0x64,0x73,0x82,0x91,0xa0,0xaf,0xbe,0xcd,0xdc,0xeb,0xfa
};

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    static HpkeContext *ctx = NULL;
    if (!ctx) {
        ctx = hpke_init_from_raw(kServerSk, kClientPk, "fuzzclient");
        if (!ctx) return 0;
    }
    HpkePayload pl;
    uint8_t aad[16];
    memset(aad, 0, sizeof(aad));
    // Vary aad_len depending on input to cover both 0 and >0 paths
    size_t aad_len = (size % 2) ? 7 : 0;
    (void)hpke_verify_and_decrypt(ctx, aad, aad_len, data, size, &pl);
    return 0;
}



